<html>
  <head>
    <title>atomic - atomic API documentation</title>
    <link href="static/favicon.png" rel="icon" />
    <link href="static/favicon.png" rel="shortcut icon" />
    <link media="all" type="text/css" href="static/clojure.css" rel="stylesheet" />
    <link media="all" type="text/css" href="static/wiki.css" rel="stylesheet" />
    <link media="all" type="text/css" href="static/internal.css" rel="stylesheet" />
    <style>.menuWrapper{height: 36px;}</style>
    <!--[if lte IE 6]>
    <link rel="stylesheet" href="http://www.wikispaces.com/_/2009051601/s/internal_ie.css" type="text/css" />
    <![endif]-->
  </head>
<!--
This document was auto-generated from the source by the clojure autodoc system.
To report errors or ask questions about the overall documentation structure, formatting,
etc., contact Tom Faulhaber (google mail name: tomfaulhaber).
For errors in the documentation of a particular namespace, contact the author of that
namespace.
-->
  <body>
    <div id="AllContentContainer">
      <div id="Header">
	<a id="Logo" href="index.html"><img alt="Clojure" height="100" width="100" src="static/clojure-icon.gif" /></a>
	<h1><a title="page header title" id="page-header" href="index.html">atomic</a></h1>
      </div>
      <div id="leftcolumn"><div style="text-align: center;"></div>
<div class="menu">
  <div class="WikiCustomNav WikiElement wiki">
    <span class="toc-header"><span id="project-name">atomic</span> <span id="version"></span> API</span><br />
    <ul>
      <li><a class="wiki_link" href="index.html">Overview</a></li>
      <li><a class="wiki_link" href="api-index.html">API Index</a></li>
    </ul>
    
    
    <a href="http://clojure.org" class="wiki_link">Clojure Home</a>
  </div>
</div>
</div>
      <div id="rightcolumn">
	<div id="Content">
	  <div class="contentBox"><div class="innerContentBox">
              <div id="content_view" class="wiki wikiPage">
                <div id="right-sidebar"><div id="toc">
  <h1 class="nopad">Table of Contents</h1>
  <div style="margin-left: 1em;" class="toc-section">
    <a href="#toc0">Overview</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/bind">bind</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/column">column</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/columns">columns</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/compile-query">compile-query</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/create">create</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/create-db">create-db</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/create-schema">create-schema</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/deftable">deftable</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/deftype?">deftype?</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/execute">execute</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/execute-sql">execute-sql</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/has-many">has-many</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/has-one">has-one</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/infix">infix</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/insert-into">insert-into</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/join-to">join-to</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/make-query">make-query</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/many">many</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/on">on</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/one">one</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/select">select</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/sql">sql</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/tx">tx</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/tx-read-only">tx-read-only</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/update">update</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic/where">where</a>
    </div>
    <br />
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#atomic.localmap">atomic.localmap</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic.localmap/create">create</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic.localmap/get">get</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic.localmap/set">set</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic.localmap/setdefault">setdefault</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic.localmap/to-map">to-map</a>
    </div>
    <br />
  </div><div style="margin-left: 1em;" class="toc-section">
    <a href="#atomic.util">atomic.util</a>
    <div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic.util/all-but-last">all-but-last</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic.util/each-in">each-in</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic.util/heads">heads</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic.util/map-in">map-in</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic.util/unflatten">unflatten</a>
    </div><div style="margin-left: 1em;" class="toc-entry">
      <a href="#atomic.util/zipn">zipn</a>
    </div>
    <br />
  </div>
</div>
</div>
                <div id="content-tag"><h1 id="overview">API for <span id="namespace-name">atomic</span>
  - <span id="header-project">atomic</span> <span id="header-version"></span>
  </h1>

<br />Full namespace name: <span id="long-name">atomic</span>
<p></p>
<h2>Overview</h2>
<pre id="namespace-docstr">Library to simplify interaction with SQL databases

Example:

  (use 'atomic)
  (def schema (create-schema))

  ; Describe a user table 
  (deftable 
    :user
    :id
    :name
    (has-many :emails :email :user_id :user))

  (deftable 
    :email
    :id
    :address
    :user_id)

  (def db (create-db "org.sqlite.JDBC" "jdbc:sqlite::memory:"))
  (execute-sql db "create table user (id integer primary key, name text, created_at integer)")
  (execute-sql db "create table email (id integer primary key, user_id integer, address text)")

  (insert db :user {:id 1 :name "Brandon"})
  (insert db :email {:address "foo@bar.com" :user_id 1})
  (insert db :email {:address "bar@bar.com" :user_id 1})

  (println (-&gt; select 
               (from :user)
               (join :email (on (= :email.user_id :user.id)))
               (where (= :id 1))
               (execute db)))

  ; [{:user {:name "Brandon" :id 5} :email {:address "foo@bar.com" :user_id 1 :id 1}}
  ;  {:user {:name "Brandon" :id 5} :email {:address "bar@bar.com" :user_id 1 :id 2}}]

  ; Easy-join graph API (one/many):
  ; Get the "Brandon" record, and join in the related emails

  (println (one db :user :emails (= (:name "Brandon")))) 
  ; [{:name "Brandon" :id 5 :emails [{:address "foo@bar.com" :user_id 1 :id 1} {:address "bar@bar.com" :user_id 1 :id 2}]}]


</pre>


<br />
<h2>Public Variables and Functions</h2>
<div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/bind">bind</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (bind v)
</pre>
  <pre id="var-docstr">Bind a value to be escaped</pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/column">column</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (column a-keyword &amp; params)
</pre>
  <pre id="var-docstr">Define a column

Arguments
name -- string, the key of the column
options
  :initial -- use this value on insert if none is provided 
  :default -- use this value on update if none is provided
  :name -- the name of the column in the table

Returns
Column
</pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/columns">columns</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (columns query &amp; cols)
</pre>
  <pre id="var-docstr">Specify a list of (columns [:u.id [:user :id] ] </pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/compile-query">compile-query</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (compile-query query schema)
</pre>
  <pre id="var-docstr">Compile a query.

Arguments
query -- map, the query

Returns
A map with the following keys
  :text -- string, the SQL text
  :bind -- list, a list of literals to bind
</pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/create">create</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (create db table props)
</pre>
  <pre id="var-docstr">Create a row, returning its insert ID</pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/create-db">create-db</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (create-db driver url &amp; opts)
</pre>
  <pre id="var-docstr">Create a new db instance.

A db is a handle to a schema and a database URL.  

Calls to (execute db... ) and (execute-sql db) will lazily create and
maintain thread-local connections 
</pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/create-schema">create-schema</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (create-schema)
</pre>
  <pre id="var-docstr">Create a schema object.

Schema objects store table and foreign key definitions.  For simple
applications this doesn't need to be called directly, usually you
can use the default global schema object.  This is useful if you need to
maintain multiple, conflicting table definitions in one
application. 

Example:
  ; Create a schema object:
  (def my-schema (create-schema))

  ; Use my-schema in :my_table's definition:
  (deftable :my_table {:schema my-schema}))
</pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/deftable">deftable</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (deftable key &amp; opts)
</pre>
  <pre id="var-docstr">Define a table

This has a couple of argument forms

Here are some examples:
  (deftable :company
    :id
    :title)
   
  (deftable :company
    (column :id)
    (column :title)
    (has-many :employees :user :company_id)) 

  (deftable :company
    (column :id)
    (column :title)
    {:schema some-schema}) 

The first column specified defaults to the primary-key column.

</pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/deftype?">deftype?</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (deftype? a-key)
</pre>
  <pre id="var-docstr">Create a function which checks the :type of a map

This is useful for storing casual types in maps. 

For example "(deftype? car)" will define a function named "car?" which checks its argument
for having the :type key set to :car 

Arguments
a-key -- symbol, the name of the keyword and defined function
</pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/execute">execute</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (execute query db)
</pre>
  <pre id="var-docstr">Run a query against an db</pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/execute-sql">execute-sql</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (execute-sql db sql)
       (execute-sql db sql params)
</pre>
  <pre id="var-docstr">Execute a SQL query.

Arguments
db -- db
sql -- string, a SQL query
params -- [literals], a list of bind values 

Returns
A map with the following keys
 :rows -- a list of row tuples if any
 :update-count -- int, the number of updated rows if any
 :generated-keys -- list, a list of generated keys (insert / sequence IDs).  Usually like [[25]] 
</pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/has-many">has-many</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (has-many key table column)
       (has-many key table column reverse)
</pre>
  <pre id="var-docstr">Get a has-many foreign key

 This is used in a deftable call.

 For example:

   (deftable :user 
     (column :id)
     (column :name)
     (column :company_id))

  (deftable :company
     (column :id)
     (column :title)
     (has-many :employees :user :company_id :employer))

 Arguments
 key -- keyword, the name of the relation
 table -- keyword, the name of the destination table
 column -- keyword, the column name in the destination table
 reverse -- keyword, the name of the reverse relation

 Returns
 A map with :type :has-many set 
 </pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/has-one">has-one</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (has-one key table column)
       (has-one key table column reverse)
</pre>
  <pre id="var-docstr">Get a has-one foreign key

 This is used in a deftable call.

 For example:

   (deftable :user 
     (column :id)
     (column :name)
     (column :company_id)
     (has-one :employer :company :company_id :employees))

 Arguments
 key -- keyword, the name of the relation
 table -- keyword, the name of the destination table
 column -- keyword, the column name in the source table
 reverse -- keyword, the name of the reverse relation

 Returns
 A map with :type :has-one set
 </pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/infix">infix</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (infix op)
</pre>
  <pre id="var-docstr">Generate a function which takes two arguments

For example:
  (infix "+") generates a function which takes two arguments and will
compile to a SQL expression like "$left + $right"
</pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/insert-into">insert-into</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (insert-into table values)
</pre>
  <pre id="var-docstr">Get an insert query

Usage:
  (-&gt; (insert-into :user {:name "Brandon"})
      (execute db))
</pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/join-to">join-to</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (join-to db table relation-paths result-set)
</pre>
  <pre id="var-docstr">Join a set of dotted relation-paths to a result set.

In other words, fill-in a list of related row objects.

For instance if you have a schema like:

  driver (id, name)
  car (id, driver_id, garage_id, name)
  garage (id, house_id)
  house (id)

(join-to db :review [:user :user.emails] [{:id 1 :user_id 3}]) =&gt;
  [{:id 1 :user_id 3 :user { :id 3 :emails [{:id 1 :address "foo@bar.com"}]}}]
</pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/make-query">make-query</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (make-query db entity where-parts)
</pre>
  <pre id="var-docstr">make a query given an entity and some where-conditions</pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/many">many</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (many db entity &amp; options)
</pre>
  <pre id="var-docstr">Get many items</pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/on">on</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (on &amp; clauses)
</pre>
  <pre id="var-docstr">Add an ON clause to a join clause

See "where"
</pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/one">one</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (one db entity &amp; options)
</pre>
  <pre id="var-docstr">Get one item

Examples

  : Load a user with id 5
  (one db :user (&gt; :id 5)) 

  ; Load a user with id 3, and review and review.business joined
  (one db :user (= :id 3) :review :review.business) 
  
  ; Load a user with id 5 and email joined
  (one db :user (= :id 5) :email) 
  
  ; Load a user with id 5 and email joined
  (one db :user (= :id 5) :emails)) 
</pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/select">select</h2>
  <span id="var-type">var</span><br />
  <pre id="var-usage"></pre>
  <pre id="var-docstr">A empty select query

Usage:
  (-&gt; select
      (from :user)
      (where (= :name "Brandon"))
      (execute db))

</pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/sql">sql</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (sql text &amp; values)
</pre>
  <pre id="var-docstr">Generate a SQL expression</pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/tx">tx</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (tx db &amp; body)
</pre>
  <pre id="var-docstr">Perform a transaction for a database

 When an exception occurs inside of this block, a rollback is executed and the exception is re-thrown.

 For example:
   (tx db
     (execute-sql "delete from my_table where id = ?" [5]))
  
 </pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/tx-read-only">tx-read-only</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (tx-read-only db &amp; body)
</pre>
  <pre id="var-docstr">Run a block of commands for a database in a read-only transaction wrapper</pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/update">update</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (update table values)
</pre>
  <pre id="var-docstr">Get an update query

Usage:
  (-&gt; (update :user {:name "Brandon"})
      (where (= :id 5))
      (execute db))
</pre>
  
  
  
</div><div id="var-entry">
  <br />
  <hr />
  <h2 id="atomic/where">where</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (where query &amp; clauses)
</pre>
  <pre id="var-docstr">Add a where clause to a query. 

Arguments
query -- a query
clauses* -- one or more clauses

Returns
query
</pre>
  
  
  
</div>
<h2 id="namespace-name">atomic.localmap</h2>
<pre id="namespace-docstr">Mutable thread-local map data structure 

This is useful for isolating state from multiple threads.  Values will be
garbage collected on thread destruction.

Usage:
  (let [my-map (localmap/create)]
    (localmap/set my-map :my-key 25)
    (localmap/to-map my-map)) ; =&gt; {:my-key 25}
</pre>


<br />
<div id="var-entry">
  <hr />
  <h2 id="atomic.localmap/create">create</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (create)
</pre>
  <pre id="var-docstr">Create a thread local-map</pre>
  
  
  
</div><div id="var-entry">
  <hr />
  <h2 id="atomic.localmap/get">get</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (get localmap key)
</pre>
  <pre id="var-docstr">Lookup a key

Arguments
localmap -- localmap
key -- the key to lookup
</pre>
  
  
  
</div><div id="var-entry">
  <hr />
  <h2 id="atomic.localmap/set">set</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (set localmap key val)
</pre>
  <pre id="var-docstr">Set a value for key

Arguments
localmap -- localmap
key -- the key 
val -- the value
</pre>
  
  
  
</div><div id="var-entry">
  <hr />
  <h2 id="atomic.localmap/setdefault">setdefault</h2>
  <span id="var-type">macro</span><br />
  <pre id="var-usage">Usage: (setdefault localmap key func)
</pre>
  <pre id="var-docstr">Set a default value for key

Arguments
localmap -- the localmap
key -- the key
func -- get the value from this function if the key doesn't exist

Returns
the defaulted value
</pre>
  
  
  
</div><div id="var-entry">
  <hr />
  <h2 id="atomic.localmap/to-map">to-map</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (to-map localmap)
</pre>
  <pre id="var-docstr">Get a map

Arguments
localmap -- the localmap

Returns
map
</pre>
  
  
  
</div>
<h2 id="namespace-name">atomic.util</h2>
<pre id="namespace-docstr"></pre>


<br />
<div id="var-entry">
  <hr />
  <h2 id="atomic.util/all-but-last">all-but-last</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (all-but-last a-seq)
</pre>
  <pre id="var-docstr">Get all but the last element of a sequence</pre>
  
  
  
</div><div id="var-entry">
  <hr />
  <h2 id="atomic.util/each-in">each-in</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (each-in func key-paths subj)
</pre>
  <pre id="var-docstr">Call func for each value in subj matching key-path</pre>
  
  
  
</div><div id="var-entry">
  <hr />
  <h2 id="atomic.util/heads">heads</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (heads a)
</pre>
  <pre id="var-docstr">Get all of the prefixes ef a</pre>
  
  
  
</div><div id="var-entry">
  <hr />
  <h2 id="atomic.util/map-in">map-in</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (map-in func key-paths subj)
</pre>
  <pre id="var-docstr">Replace each value in subj with matching key-path</pre>
  
  
  
</div><div id="var-entry">
  <hr />
  <h2 id="atomic.util/unflatten">unflatten</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (unflatten rows key-paths)
</pre>
  <pre id="var-docstr">Build a nested result set from a set of key paths</pre>
  
  
  
</div><div id="var-entry">
  <hr />
  <h2 id="atomic.util/zipn">zipn</h2>
  <span id="var-type">function</span><br />
  <pre id="var-usage">Usage: (zipn &amp; seqs)
</pre>
  <pre id="var-docstr">Python / ML / Haskell style zip</pre>
  
  
  
</div>


</div>
              </div>
            </div>
          </div>
	</div>
	<div id="foot">
	  <div style="text-align: center;" id="copyright">No copyright info </div>
	</div>
      </div>
      <div id="DesignedBy">Logo &amp; site design by <a title="Visit Tom Hickey's website." href="http://www.tomhickey.com">Tom Hickey</a>.<br />
      Clojure auto-documentation system by Tom Faulhaber.</div>
    </div>
    <!-- /AllContentContainer -->
  </body>

</html>